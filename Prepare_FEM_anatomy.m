% 0) Notes

% This script will prepare anatomy with a FEM
% If not willing to get EEG or BIMODAL sources, use Prepare_anatomy instead
% For this to run, subject_array column 11 must have 'import_T1' on it

% It involves some manual steps in within (e.g. define fiducials), for
% which we recomend running all but SECTION 3 on gui

% Developed for CNRL by User López-Caballero
%% Define input

% Will always be ran in the server (FEM takes hours)
clear 
% Main path where MRI and HCPproc folders are
root_dir = '/private/CNRL/private/Project'; % where to find HCPproc
% Path where 'anat' folder for your project is (in case it differs from main)
anat_path = '/private/CNRL/Project/brainstorm_db/Project_baseline'; % Project_baseline, or Project_followup
% Protocol name as in '~/brainstorm_db' (remember to run this in CNRL98)
Defined_protocol_name = 'Project_baseline'; 
% Load subject array for this project
load([root_dir '/User/' Defined_protocol_name '/subject_array.mat'])
% Define subject list with names AS THEY APPEAR IN BRAINSTORM
participant = {subject_array{:,1}};
% Define subject list with names AS THEY APPEAR IN HCPROC AND MRI FOLDERS (should be the same in the case of Project) 
participant_MRI_folder = {subject_array{:,1}};
% If corregistration was already made, you may want to get the head mask 
% back once this is ran. Should be the same but just in case
preserve_head_mask = 0; % 0 = DON'T; 1 = DO % We are doing this from scratch in Project, so 0
% Main folder where you have your backups before running this (CREATE THEM MANUALLY IF YOU DON'T HAVE THEM ALREADY)
backup_before_FEM = '/private/project/Project/brainstorm_db/Project_baseline'; % If needed, but we are not doing it
% Folder to store backup after FEM (Will be generated by this script if willing to)
backup_after_FEM = [root_dir '/User/Archive/Anats_after_FEM']; % 

% These have to remain like this most likely
nVertices = 15000; nVertHemi = round(nVertices / 2);
% This path has to be like this, as some functions used are only here
addpath('/private/project/HuMon/Brainstorm_pipelines/custom_functions');
% Automatic answer to brainstorm question when importing surfaces:
% "MRI orientation was non-standard and had to be reoriented. 
% Apply the same transformation to the surfaces?"
apply_MRI_transform = 1; % 0 = DON'T; 1 = DO 
security_copy_new_fem = 1; % Create a security copy or not of the new fem anatomy created

%% (OPTIONAL) Run in server mode: Set Brainstorm nogui on completely headless mode (Baseline) 

% Set up the Brainstorm files
clear
% addpath('~/matlab/brainstorm3'); 
% addpath('/mnt/RAID/matlab/brainstorm3_v20220706');
addpath('/mnt/RAID/matlab/brainstorm3_v20220706');
BrainstormDbDir = '/private/project/Project/brainstorm_db';
% Start Brainstorm
if ~brainstorm('status')
    brainstorm server
end
bst_set('BrainstormDbDir',BrainstormDbDir)
% Select the correct protocol
ProtocolName = 'Project_baseline'; % Enter the name of your protocol
sProtocol.Comment = ProtocolName;
sProtocol.SUBJECTS = '/private/project/Project/brainstorm_db/Project_baseline/anat';
sProtocol.STUDIES = '/private/project/Project/brainstorm_db/Project_baseline/data';
db_edit_protocol('load',sProtocol);
% Get the protocol index
iProtocol = bst_get('Protocol', ProtocolName);
if isempty(iProtocol)
    error(['Unknown protocol: ' ProtocolName]);
end
% Select the current procotol
gui_brainstorm('SetCurrentProtocol', iProtocol);

%% SECTION 1) Load T1 for FEM

for p = 1:length(participant)
    pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
    if strcmp(subject_array{pos_subj,11},'import_T1')
    % Define subject in brainstorm
    prot_subs = bst_get('ProtocolSubjects');
    iSubject = find(strcmp({prot_subs.Subject.Name}, participant{p}));
    
    % Reload anatomy folder before moving forward
    db_reload_subjects(iSubject)

    % Exclude obvious errors
    if ~exist([root_dir '/HCPproc/' participant_MRI_folder{p}],'dir')
        subject_array{pos_subj,11} = 'No_HCP_folder';
        continue;
    end
    
    % Define MRI files to import (as stated in CNRL wiki)
    T1_file_name = dir([root_dir '/HCPproc/' participant_MRI_folder{p} '/*/T1w/T1w_acpc_dc_restore.nii.gz']);
    if isempty(T1_file_name)
        % Try this name
        warning(['original T1 file not present for ' participant{p} ': looking for alternatives..']);
        T1_file_name = dir([root_dir '/HCPproc/' participant_MRI_folder{p} '/*/T1w/*T1w.nii_acpc_dc_restore.nii.gz']);
        if isempty(T1_file_name) % if it's still empty
            error(['No T1 found for ' participant_MRI_folder{p}]);
        end
    end

    disp(' ');      
    disp('-------------------------');  
    disp(['Importing T1 for FEM for ' participant{p}]);
    disp(datetime)
    disp(' ');  

    % Load T1
    MriFile = {[T1_file_name.folder filesep T1_file_name.name]};
    CNRL_import_mri(iSubject, MriFile, 'ALL', 0, 1, 'T1_FEM')
    
    subject_array{pos_subj,11} = 'needs_fiducials';
    save([root_dir '/User/' Defined_protocol_name '/subject_array.mat'],'subject_array');   
    end
end

disp('Done importing T1 for FEM!');

%% !) Set fiducials and update subject_array with 'import_T2'

%% SECTION 2) Load T2 for FEM

for p = 1:length(participant)
    pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
    if strcmp(subject_array{pos_subj,11},'import_T2')
    % Define subject in brainstorm
    prot_subs = bst_get('ProtocolSubjects');
    iSubject = find(strcmp({prot_subs.Subject.Name}, participant{p}));
    
    % Reload anatomy folder before moving forward
    db_reload_subjects(iSubject)

    % Exclude obvious errors
    if ~exist([root_dir '/HCPproc/' participant_MRI_folder{p}],'dir')
        subject_array{pos_subj,11} = 'No_HCP_folder';
        continue;
    end
    
    % Define MRI files to import (as stated in CNRL wiki)
    T2_file_name = dir([root_dir '/HCPproc/' participant_MRI_folder{p} '/*/T1w/T2w_acpc_dc_restore.nii.gz']);
    if isempty(T2_file_name)
        % Try this name
        warning(['original T2 file not present for ' participant{p} ': looking for alternatives..']);
        T2_file_name = dir([root_dir '/HCPproc/' participant_MRI_folder{p} '/*/T1w/*T2w.nii_acpc_dc_restore.nii.gz']);
        if isempty(T2_file_name) % If it's still empty
            error(['No T2 found for ' participant_MRI_folder{p}]);
        end
    end

    disp(' ');      
    disp('-------------------------');  
    disp(['Importing T2 for FEM for ' participant{p}]);
    disp(datetime)
    disp(' ');  

    % Load T2
    MriFile = {[T2_file_name.folder filesep T2_file_name.name]};
    CNRL_import_mri(iSubject, MriFile, 'ALL', 0, 1, 'T2_FEM')
    
    subject_array{pos_subj,11} = 'needs_FEM';
    save([root_dir '/User/' Defined_protocol_name '/subject_array.mat'],'subject_array');   
    end
end

disp('Done importing T2 for FEM!');

%% SECTION 3) Compute FEMs with imported T1 and T2 (Takes hours to compute)

% Select the T1 and T2 that you imported, as you would do with the gui
% according to: https://neuroimage.usc.edu/brainstorm/Tutorials/FemMesh: 
% "If you have T1 and T2, you need to call this process by a right-click on the subject 
% in order to include the two datasets, or you can select the T1 and T2 then call 
% the Generate FEM mesh process."

for p = 1:length(participant)
    pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
    if strcmp(subject_array{pos_subj,11},'needs_FEM')
    % Define subject in brainstorm
    prot_subs = bst_get('ProtocolSubjects');
    iSubject = find(strcmp({prot_subs.Subject.Name}, participant{p}));
    sSubject = bst_get('Subject', iSubject);
    
    % Reload anatomy folder before moving forward
    db_reload_subjects(iSubject)
    
    % Define positions of T1 and T2 in brainstorm based on subject
    pos_T1_FEM = find(contains({sSubject.Anatomy.FileName},'T1_FEM'));
    pos_T2_FEM = find(contains({sSubject.Anatomy.FileName},'T2_FEM'));
    iMris = [pos_T1_FEM, pos_T2_FEM];
    
    % Define parameters
    OPTIONS = struct(...
        'Method',         'simnibs', ...      % {'iso2mesh', 'brain2mesh', 'simnibs', 'roast', 'fieldtrip'}
        'MeshType',       'tetrahedral', ...   % iso2mesh: 'tetrahedral';  simnibs: 'tetrahedral';  roast:'hexahedral'/'tetrahedral';  fieldtrip:'hexahedral'/'tetrahedral' 
        'MaxVol',         0.1, ...             % iso2mesh: Max tetrahedral volume (10=coarse, 0.0001=fine)
        'KeepRatio',      100, ...             % iso2mesh: Percentage of elements kept (1-100%)
        'BemFiles',       [], ...              % iso2mesh: List of layers to use for meshing (if not specified, use the files selected in the database 
        'MergeMethod',    'mergemesh', ...     % iso2mesh: {'mergemesh', 'mergesurf'} Function used to merge the meshes
        'VertexDensity',  0.5, ...             % SimNIBS: [0.1 - X] setting the vertex density (nodes per mm2)  of the surface meshes
        'NbVertices',     nVertices, ...       % SimNIBS: Number of vertices for the cortex surface imported from CAT12 
        'NodeShift',      0.3, ...             % FieldTrip: [0 - 0.49] Improves the geometrical properties of the mesh
        'Downsample',     3, ...               % FieldTrip: Integer, Downsampling factor to apply to the volumes before meshing
        'Zneck',          -115); 
    
% Process: Generate FEM mesh
sFiles = bst_process('CallProcess', 'process_fem_mesh', sFiles, [], ...
    'subjectname',   SubjectNames{1}, ...
    'method',        'simnibs', ...  % SimNIBS:Call SimNIBS to segment and mesh the T1 (and T2) MRI.
    'mergemethod',   'mergemesh', ...  % mergemesh
    'maxvol',        0.1, ...
    'keepratio',     100, ...
    'vertexdensity', 0.5, ...
    'nvertices',     nVertices, ...
    'downsample',    3, ...
    'nodeshift',     0.3, ...
    'zneck',         -115);
    
    
    disp(' ');      
    disp('-------------------------');  
    disp(['Computing FEM for ' participant{p}]);
    disp(datetime)
    disp(' '); 
    
    % Run fem mesh without interactive mode (should not ask anything)
    process_fem_mesh('Compute', iSubject, iMris, 0, OPTIONS)
    end
    subject_array{pos_subj,11} = 'needs_re_import_HCP';
    save([root_dir '/User/' Defined_protocol_name '/subject_array.mat'],'subject_array')  
end

disp('Done computing FEM!');

%% (OPTIONAL) Make security copy of FEM generated files before replacing stuff

if security_copy_new_fem == 1
for p = 1:length(participant)
    
    % Create main folder if it doesn't exist already
    if ~exist(backup_after_FEM,'dir')
        mkdir(backup_after_FEM);
    end
    
    disp(' ');      
    disp('-------------------------');  
    disp(['Making a backup copy of anatomy after FEM for ' participant{p}]);
    disp(datetime)
    disp(' '); 
    
    % Copy anat folder from brainstorm to backup after FEM
    if ~exist([backup_after_FEM '/' participant{p}],'dir')
        mkdir([backup_after_FEM '/'], [participant{p} '/']);
        copyfile([anat_path '/anat/' participant{p}],[backup_after_FEM '/' participant{p}]);
    else % If folder exists, copy the potential newly generated contens on the folder
        copyfile([anat_path '/anat/' participant{p}],[backup_after_FEM '/' participant{p}]);
    end
    
end

disp('Done making backup after FEM!');

end

%% SECTION 4) Re-import HCP parcellations onto new space

for p = 1:length(participant)
    pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
    if strcmp(subject_array{pos_subj,11},'needs_re_import_HCP') 
    prot_subs = bst_get('ProtocolSubjects');
    iSubject = find(strcmp({prot_subs.Subject.Name}, participant{p}));
    % Reload anatomy folder before moving forward
    db_reload_subjects(iSubject)

    % Define Freesurfer folder
    Prep_FsDir = dir([root_dir '/HCPproc/' participant_MRI_folder{p} '/*/T1w/' participant_MRI_folder{p}]);
    if isempty(Prep_FsDir)
        error(['no Freesurfer folder in ' root_dir '/HCPproc/' participant_MRI_folder{p} '/*/T1w/' participant_MRI_folder{p}]);
    end
    FsDir = Prep_FsDir(1).folder;
    FsDir = strrep(FsDir,'\','/'); % Just to be sure

    % Delete previous cortices with names that will be replaced
    current_subject_anat = dir([anat_path '/anat/' participant{p}]);
    % pial_low
    pos = find(contains({current_subject_anat.name},'tess_cortex_pial_low.mat'));
    if ~isempty(pos)
        delete([anat_path '/anat/' participant{p} '/' current_subject_anat(pos).name]);
    end
    % pial_high
    pos = find(contains({current_subject_anat.name},'tess_cortex_pial_high.mat'));
    if ~isempty(pos)
        delete([anat_path '/anat/' participant{p} '/' current_subject_anat(pos).name]);
    end
    % white_low
    pos = find(contains({current_subject_anat.name},'tess_cortex_white_low.mat'));
    if ~isempty(pos)
        delete([anat_path '/anat/' participant{p} '/' current_subject_anat(pos).name]);
    end
    % white_high
    pos = find(contains({current_subject_anat.name},'tess_cortex_white_high.mat'));
    if ~isempty(pos)
        delete([anat_path '/anat/' participant{p} '/' current_subject_anat(pos).name]);
    end

    % As they will be replaced by the new ones imported and we don't want new
    % names. Output surfaces that will be used are named:
    % 'tess_cortex_pial_low.mat'
    % 'tess_cortex_pial_high.mat'
    
    disp(' ');      
    disp('-------------------------');  
    disp(['Re-importing HCP surfaces into FEM space for ' participant{p}]);
    disp(datetime)
    disp(' '); 
    
    % ===== FIND FILES AND ANNOTS =====
    % Find surfaces
    TessLhFile = file_find(FsDir, 'lh.pial', 2);
    TessRhFile = file_find(FsDir, 'rh.pial', 2);
    TessLwFile = file_find(FsDir, 'lh.white', 2);
    TessRwFile = file_find(FsDir, 'rh.white', 2);

    % Find annot labels
    AnnotLhFiles = {file_find(FsDir, 'lh.pRF.annot', 2), file_find(FsDir, 'lh.aparc.a2009s.annot', 2), file_find(FsDir, 'lh.aparc.annot', 2), file_find(FsDir, 'lh.aparc.DKTatlas40.annot', 2), file_find(FsDir, 'lh.aparc.DKTatlas.annot', 2), file_find(FsDir, 'lh.BA.annot', 2), file_find(FsDir, 'lh.BA.thresh.annot', 2), file_find(FsDir, 'lh.HCPMMP1.annot', 2), file_find(FsDir, 'lh.BA_exvivo.annot', 2), file_find(FsDir, 'lh.BA_exvivo.thresh.annot', 2), ...
                    file_find(FsDir, 'lh.myaparc_36.annot', 2), file_find(FsDir, 'lh.myaparc_60.annot', 2), file_find(FsDir, 'lh.myaparc_125.annot', 2), file_find(FsDir, 'lh.myaparc_250.annot', 2), file_find(FsDir, 'lh.BN_Atlas.annot', 2), file_find(FsDir, 'lh.oasis.chubs.annot', 2), ...
                    file_find(FsDir, 'lh.PALS_B12_Brodmann.annot', 2), file_find(FsDir, 'lh.PALS_B12_Lobes.annot', 2), file_find(FsDir, 'lh.PALS_B12_OrbitoFrontal.annot', 2), file_find(FsDir, 'lh.PALS_B12_Visuotopic.annot', 2), file_find(FsDir, 'lh.Yeo2011_7Networks_N1000.annot', 2), file_find(FsDir, 'lh.Yeo2011_17Networks_N1000.annot', 2)};
    AnnotRhFiles = {file_find(FsDir, 'rh.pRF.annot', 2), file_find(FsDir, 'rh.aparc.a2009s.annot', 2), file_find(FsDir, 'rh.aparc.annot', 2), file_find(FsDir, 'rh.aparc.DKTatlas40.annot', 2), file_find(FsDir, 'rh.aparc.DKTatlas.annot', 2), file_find(FsDir, 'rh.BA.annot', 2), file_find(FsDir, 'rh.BA.thresh.annot', 2), file_find(FsDir, 'rh.HCPMMP1.annot', 2), file_find(FsDir, 'rh.BA_exvivo.annot', 2), file_find(FsDir, 'rh.BA_exvivo.thresh.annot', 2), ...
                    file_find(FsDir, 'rh.myaparc_36.annot', 2), file_find(FsDir, 'rh.myaparc_60.annot', 2), file_find(FsDir, 'rh.myaparc_125.annot', 2), file_find(FsDir, 'rh.myaparc_250.annot', 2), file_find(FsDir, 'rh.BN_Atlas.annot', 2), file_find(FsDir, 'rh.oasis.chubs.annot', 2), ...
                    file_find(FsDir, 'rh.PALS_B12_Brodmann.annot', 2), file_find(FsDir, 'rh.PALS_B12_Lobes.annot', 2), file_find(FsDir, 'rh.PALS_B12_OrbitoFrontal.annot', 2), file_find(FsDir, 'rh.PALS_B12_Visuotopic.annot', 2), file_find(FsDir, 'rh.Yeo2011_7Networks_N1000.annot', 2), file_find(FsDir, 'rh.Yeo2011_17Networks_N1000.annot', 2)};
    AnnotLhFiles(cellfun(@isempty, AnnotLhFiles)) = [];
    AnnotRhFiles(cellfun(@isempty, AnnotRhFiles)) = [];
    % Remove old labels
    if ~isempty(AnnotLhFiles) && ~isempty(AnnotRhFiles)
        % Freesurfer 5.3 creates "BA.annot", Freesurfer 6 creates "BA_exvivo.annot" 
        % If the two are available in the same folder, both versions were executed, and the old "BA.annot" is outdated but not replaced: ignore it
        % Left
        iBAold = find(~cellfun(@(c)isempty(strfind(c, 'BA.annot')), AnnotLhFiles));
        iBAnew = find(~cellfun(@(c)isempty(strfind(c, 'BA_exvivo.annot')), AnnotLhFiles));
        if ~isempty(iBAold) && ~isempty(iBAnew)
            AnnotLhFiles(iBAold) = [];
        end
        % Right
        iBAold = find(~cellfun(@(c)isempty(strfind(c, 'BA.annot')), AnnotRhFiles));
        iBAnew = find(~cellfun(@(c)isempty(strfind(c, 'BA_exvivo.annot')), AnnotRhFiles));
        if ~isempty(iBAold) && ~isempty(iBAnew)
            AnnotRhFiles(iBAold) = [];
        end
    end

    % ===== IMPORT SURFACES =====
    % Left pial
    if ~isempty(TessLhFile)
        [iLh, BstTessLhFile, nVertOrigL] = import_surfaces_User(iSubject, TessLhFile, 'FS', apply_MRI_transform);
        BstTessLhFile = BstTessLhFile{1};
        % Load atlases
        if ~isempty(AnnotLhFiles)
            bst_progress('start', 'Import FreeSurfer folder', 'Loading atlases: left pial...');
            [sAllAtlas, err] = import_label(BstTessLhFile, AnnotLhFiles, 1);
        end
        % Downsample
        bst_progress('start', 'Import FreeSurfer folder', 'Downsampling: left pial...');
        [BstTessLhLowFile, iLhLow, xLhLow] = tess_downsize(BstTessLhFile, nVertHemi, 'reducepatch');
    end
    % Right pial
    if ~isempty(TessRhFile)
        % Import file
        [iRh, BstTessRhFile, nVertOrigR] = import_surfaces_User(iSubject, TessRhFile, 'FS', apply_MRI_transform);
        BstTessRhFile = BstTessRhFile{1};
        % Load atlases
        if ~isempty(AnnotRhFiles)
            bst_progress('start', 'Import FreeSurfer folder', 'Loading atlases: right pial...');
            [sAllAtlas, err] = import_label(BstTessRhFile, AnnotRhFiles, 1);
        end
        % Downsample
        bst_progress('start', 'Import FreeSurfer folder', 'Downsampling: right pial...');
        [BstTessRhLowFile, iRhLow, xRhLow] = tess_downsize(BstTessRhFile, nVertHemi, 'reducepatch');
    end
    % Left white matter
    if ~isempty(TessLwFile)
        % Import file
        [iLw, BstTessLwFile] = import_surfaces_User(iSubject, TessLwFile, 'FS', apply_MRI_transform);
        BstTessLwFile = BstTessLwFile{1};
        % Load atlases
        if ~isempty(AnnotLhFiles)
            bst_progress('start', 'Import FreeSurfer folder', 'Loading atlases: left white...');
            [sAllAtlas, err] = import_label(BstTessLwFile, AnnotLhFiles, 1);
        end
        % Downsample
        bst_progress('start', 'Import FreeSurfer folder', 'Downsampling: left white...');
        [BstTessLwLowFile, iLwLow, xLwLow] = tess_downsize(BstTessLwFile, nVertHemi, 'reducepatch');
    end
    % Right white matter
    if ~isempty(TessRwFile)
        % Import file
        [iRw, BstTessRwFile] = import_surfaces_User(iSubject, TessRwFile, 'FS', apply_MRI_transform);
        BstTessRwFile = BstTessRwFile{1};
        % Load atlases
        if ~isempty(AnnotRhFiles)
            bst_progress('start', 'Import FreeSurfer folder', 'Loading atlases: right white...');
            [sAllAtlas, err] = import_label(BstTessRwFile, AnnotRhFiles, 1);
        end
        % Downsample
        bst_progress('start', 'Import FreeSurfer folder', 'Downsampling: right white...');
        [BstTessRwLowFile, iRwLow, xRwLow] = tess_downsize(BstTessRwFile, nVertHemi, 'reducepatch');
    end

    % ===== MERGE SURFACES =====
    rmFiles = {};
    % Merge hemispheres: pial
    if ~isempty(TessLhFile) && ~isempty(TessRhFile)
        % Hi-resolution surface
        CortexHiFile  = tess_concatenate({BstTessLhFile,    BstTessRhFile},    sprintf('cortex_%dV', nVertOrigL + nVertOrigR), 'Cortex');
        CortexLowFile = tess_concatenate({BstTessLhLowFile, BstTessRhLowFile}, sprintf('cortex_%dV', length(xLhLow) + length(xRhLow)), 'Cortex');
        % Delete separate hemispheres
        rmFiles = cat(2, rmFiles, {BstTessLhFile, BstTessRhFile, BstTessLhLowFile, BstTessRhLowFile});
        % Rename high-res file
        oldCortexHiFile = file_fullpath(CortexHiFile);
        CortexHiFile    = bst_fullfile(bst_fileparts(oldCortexHiFile), 'tess_cortex_pial_high.mat');
        file_move(oldCortexHiFile, CortexHiFile);
        CortexHiFile = file_short(CortexHiFile);
        % Rename high-res file
        oldCortexLowFile = file_fullpath(CortexLowFile);
        CortexLowFile    = bst_fullfile(bst_fileparts(oldCortexLowFile), 'tess_cortex_pial_low.mat');
        file_move(oldCortexLowFile, CortexLowFile);
        CortexHiFile = file_short(CortexHiFile);
    else
        CortexHiFile = [];
        CortexLowFile = [];
    end
    % Merge hemispheres: white
    if ~isempty(TessLwFile) && ~isempty(TessRwFile)
        % Hi-resolution surface
        WhiteHiFile  = tess_concatenate({BstTessLwFile,    BstTessRwFile},    sprintf('white_%dV', nVertOrigL + nVertOrigR), 'Cortex');
        WhiteLowFile = tess_concatenate({BstTessLwLowFile, BstTessRwLowFile}, sprintf('white_%dV', length(xLwLow) + length(xRwLow)), 'Cortex');
        % Delete separate hemispheres
        rmFiles = cat(2, rmFiles, {BstTessLwFile, BstTessRwFile, BstTessLwLowFile, BstTessRwLowFile});
        % Rename high-res file
        oldWhiteHiFile = file_fullpath(WhiteHiFile);
        WhiteHiFile    = bst_fullfile(bst_fileparts(oldWhiteHiFile), 'tess_cortex_white_high.mat');
        file_move(oldWhiteHiFile, WhiteHiFile);
        % Rename high-res file
        oldWhiteLowFile = file_fullpath(WhiteLowFile);
        WhiteLowFile    = bst_fullfile(bst_fileparts(oldWhiteLowFile), 'tess_cortex_white_low.mat');
        file_move(oldWhiteLowFile, WhiteLowFile);
    end

    % ===== DELETE INTERMEDIATE FILES =====
    if ~isempty(rmFiles)
        % Delete files
        file_delete(file_fullpath(rmFiles), 1);
        % Reload subject
        db_reload_subjects(iSubject);
    end

    % ===== MARK NOW THE CORTEX 1500 AS DEFAULT (PIAL LOW) =====

    % Load file that specifies that
    load([anat_path '/anat/' participant{p} '/brainstormsubject.mat']);
    % Define name of default cortex
    Cortex = [participant{p} '/tess_cortex_pial_low.mat'];
    % Identify variables in file to be sure we save back the same
    variableInfo = who('-file',[anat_path '/anat/' participant{p} '/brainstormsubject.mat']);
    save([anat_path '/anat/' participant{p} '/brainstormsubject.mat'],variableInfo{:});
    % And reload folder again
    db_reload_subjects(iSubject)
    end
    subject_array{pos_subj,11} = 'needs_QC_FEM';
    save([root_dir '/User/' Defined_protocol_name '/subject_array.mat'],'subject_array')  
end

disp('Done re-importing HCP surfaces and labels into FEM space!');

%% !) Check no major issues with FEM-cortex alignment and label 'needs_atlas'

%% (OPTIONAL) Copy head mask from backup (if corregistration was already done)

% If stated
if preserve_head_mask == 1
    
for p = 1:length(participant)
    
    disp(' ');      
    disp('-------------------------');  
    disp(['Copying head mask from backup for ' participant{p}]);
    disp(datetime)
    disp(' '); 
    
    % Load file from archive that specifies which head mask was the default
    load([backup_before_FEM '/' participant{p} '/brainstormsubject.mat']);
    % Find that head mask in this subject's backup anat folder
    file_to_copy = [backup_before_FEM '/' participant{p} '/' Scalp(6:end)]; % We remove the subject name form the file name
    % Copy this scalp name (as it will be overwritten
    Name_scalp_to_copy = Scalp;
    % Load anat file that specifies current head mask (generated by FEM)
    load([anat_path '/anat/' participant{p} '/brainstormsubject.mat']);
    % Delete such head mask
    delete([anat_path '/anat/' participant{p} '/' Scalp(6:end)]);
    % Copy selected backup head mask into this anat folder
    copyfile(file_to_copy, [anat_path '/anat/' participant{p} '/' Name_scalp_to_copy(6:end)]);
    % Upadate head mask name used in brainstormsubject.mat
    Scalp = Name_scalp_to_copy;
    % Identify variables in file to be sure we save back the same
    variableInfo = who('-file',[anat_path '/anat/' participant{p} '/brainstormsubject.mat']);
    save([anat_path '/anat/' participant{p} '/brainstormsubject.mat'],variableInfo{:});
    % And reload folder again
    prot_subs = bst_get('ProtocolSubjects');
    iSubject = find(strcmp({prot_subs.Subject.Name}, participant{p}));
    db_reload_subjects(iSubject)
end
    
disp('Done with copying head masks from archive!');

end

%% SECTION 5) Create personalized atlas for each subject based on HCPMMP1 one

% Directory specification
anat_dir = ['C:/Project/brainstorm_db/' protocol '/anat/']; 

% If willing to select an specific participant, uncomment this
% participant = {'xxxx'};
% Only if wanting to do so in the common anatomy, uncomment this
% participant = {'@default_subject'};

% Example of atlas 1:
title_new_atlas = 'Auditory_and_frontal'; 
% List of scouts in HCPMMP1 atlas that will be used to create new one
new_scout_list = {'L_52_ROI L','L_A1_ROI L','L_A4_ROI L','L_A5_ROI L','L_LBelt_ROI L',...
    'L_MBelt_ROI L','L_OP4_ROI L','L_PBelt_ROI L','L_RI_ROI L','L_STSdp_ROI L','L_STSvp_ROI L',...
    'R_52_ROI R','R_A1_ROI R','R_A4_ROI R','R_A5_ROI R','R_LBelt_ROI R','R_MBelt_ROI R',...
    'R_OP4_ROI R','R_PBelt_ROI R','R_RI_ROI R','R_STSdp_ROI R','R_STSvp_ROI R', 'L_45_ROI L',...
    'L_IFSa_ROI L','L_IFSp_ROI L','R_45_ROI R','R_IFSa_ROI R','R_IFSp_ROI R'...
    'L_OFC_ROI L','L_pOFC_ROI L','R_OFC_ROI R','R_pOFC_ROI R'};

new_scout_names = {'52_L','A1_L','A4_L','A5_L','LBelt_L', ...
    'MBelt_L','OP4_L','PBelt_L','RI_L','STSdp_L','STSvp_L', ...
    '52_R','A1_R','A4_R','A5_R','LBelt_R','MBelt_R', ...
    'OP4_R','PBelt_R','RI_R','STSdp_R','STSvp_R','45_L', ...
    'IFSa_L','IFSp_L','45_R','IFSa_R','IFSp_R' ...
    'OFC_L','pOFC_L','OFC_R','pOFC_R'};

% In same order, list of new colors of scouts in new atlas
new_scout_colors = {[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]...
    [0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]...
    [0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]};

% Now Call function 
[subject_array] = local_function_personalize_scouts(root_dir, anat_dir, participant,title_new_atlas,new_scout_list,new_scout_names,new_scout_colors, subject_array);

%% SECTION 6) Merge scouts of interest

% Directory specification
anat_dir = ['C:/Project/brainstorm_db/' protocol '/anat/']; 

% If willing to select an specific participant, uncomment this
% participant = {'xxxx'};
% Only if wanting to do so in the common anatomy, uncomment this
% participant = {'@default_subject'};

which_atlas = 'Auditory_and_frontal'; % Atlas from which scouts will be merged

% As many as needed
scouts_to_merge_group = {{'A1_L','LBelt_L','PBelt_L'},{'A1_R','LBelt_R','PBelt_R'},...
    {'A1_L','LBelt_L','MBelt_L','PBelt_L'},{'A1_R','LBelt_R','MBelt_R','PBelt_R'},...
    {'45_L','IFSa_L','IFSp_L'},{'45_R','IFSa_R','IFSp_R'},...
    {'OFC_L', 'pOFC_L'},{'OFC_R', 'pOFC_R'}}; % Exactly as they appear in Atlas
name_merged_scout_group = {'AUDCORTEX3ROI_L','AUDCORTEX3ROI_R','AUDCORTEX_L','AUDCORTEX_R',...
    'IFG_L','IFG_R','OFC_L_merged','OFC_R_merged'};

merged_scout_color = [0,0,0]; % in RGB
remove_original_scouts = 0; % 0 = NO; 1 = YES; % remove or not the original individual scouts merged

% Now Call function 
[subject_array] = local_function_merge_scouts(root_dir, anat_dir, participant,which_atlas,scouts_to_merge_group,name_merged_scout_group,merged_scout_color,remove_original_scouts, subject_array);

%%  Final message

disp 'After running this, and before computing forward models for sources, ensure EEG electrodes are projected to the surface (manually)';

%% Local function stored (don't need to touch)

function [subject_array] = local_function_personalize_scouts(root_dir, anat_dir, participant,title_new_atlas,new_scout_list,new_scout_names,new_scout_colors, subject_array)

for p = 1:length(participant)
    % Sources-or-anatomy-specific problems
    if ~strcmp(participant{p},'@default_subject')
        pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
        if ~strcmp(subject_array{pos_subj,11},'needs_atlas')
            continue; % on to next subject
        end
    else
        disp('Changing default anatomy scouts');
    end
    if ~exist([anat_dir participant{p} '/brainstormsubject.mat'],'file');continue;end
    load([anat_dir participant{p} '/brainstormsubject.mat'])    
    load([anat_dir Cortex]) % contains the atlas
    pos_new = find(strcmp({Atlas.Name},title_new_atlas)); %#ok<*EFIND>
    if isempty(pos_new) % We have to create this atlas
        Pos_main_atlas = find(strcmp({Atlas.Name},'HCPMMP1'));
        % Ojo que puede ser hcpmmp1 también
        if isempty(Pos_main_atlas)
            Pos_main_atlas = find(strcmp({Atlas.Name},'hcpmmp1'));
        end
        if isempty(Pos_main_atlas)
            error(['no atlas under HCPMMP1 or hcpmmp1 names found for ' participant{p}])
        end
        % Crate new entry in Atlas with the name chosen
        Pos_new_atlas = size(Atlas,2)+1;
        Atlas(Pos_new_atlas).Name = title_new_atlas;  %#ok<*AGROW>
        % For every scout selected for this atlas, add it to the new entry
        for nal = 1:length(new_scout_list)
            Pos_orig = find(strcmp({Atlas(Pos_main_atlas).Scouts.Label},new_scout_list{nal}));
            if isempty(Pos_orig)
                error([new_scout_list{nal} ' label not found in original atlas']);
            end
            Atlas(Pos_new_atlas).Scouts(nal) = Atlas(Pos_main_atlas).Scouts(Pos_orig); %#ok<*FNDSB>
            Atlas(Pos_new_atlas).Scouts(nal).Label = new_scout_names{nal};
            Atlas(Pos_new_atlas).Scouts(nal).Color = new_scout_colors{nal}/255;
        end
        % Make it the default atlas
        iAtlas = Pos_new_atlas; %#ok<*NASGU>
        % Identify variables in file to be sure we save back the same
        variableInfo = who('-file',[anat_dir Cortex]);
        save([anat_dir Cortex],variableInfo{:})
        % Identify subject as completed
        if ~strcmp(participant{p},'@default_subject')
            subject_array{pos_subj,11} = 'needs_merge';
            save([root_dir '/subject_array.mat'],'subject_array')
        end
        
    end
end

% Reload subject
for p = 1:length(participant)
    if ~strcmp(participant{p},'@default_subject')
        pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
        % Sources-or-anatomy-specific problems
        if ~strcmp(subject_array{pos_subj,11},'needs_atlas')
            continue; % on to next subject
        end
    else
        disp('Changing default anatomy scouts');
    end
    try
        prot_subs = bst_get('ProtocolSubjects');
        if strcmp(participant{p},'@default_subject') % default anatomy
            current_sub = 0;
        else % Any subject
            current_sub = find(strcmp({prot_subs.Subject.Name}, participant{p}));
        end
        db_reload_subjects(current_sub);
    catch
        disp(['Please reload anatomy for participant ' participant{p} ' to see the new atlas'])
    end
end

end

%% Local function stored (don't need to touch)

function [subject_array] = local_function_merge_scouts(root_dir, anat_dir, participant,which_atlas,scouts_to_merge_group,name_merged_scout_group,merged_scout_color,remove_original_scouts, subject_array)
for p = 1:length(participant)
    % Sources-or-anatomy-specific problems
    pos_subj = find(strcmp({subject_array{:,1}},participant{p}));
    if ~strcmp(participant{p},'@default_subject')
        if ~strcmp(subject_array{pos_subj,11},'needs_merge')
            continue; % on to next subject
        end
    else
        disp('Changing default anatomy scouts');
    end
    
    % Once for every set of scouts we want to merge
    for scomerge = 1:length(name_merged_scout_group)
    
        % Define this merged_scout and its components
        name_merged_scout = name_merged_scout_group{scomerge};
        scouts_to_merge = scouts_to_merge_group{scomerge};
        
        if ~exist([anat_dir participant{p} '/brainstormsubject.mat'],'file');continue;end
        load([anat_dir participant{p} '/brainstormsubject.mat'])    
        load([anat_dir Cortex]) % contains the atlas
        Pos_main_atlas = find(strcmp({Atlas.Name},which_atlas));
        if isempty(Pos_main_atlas)
            error(['There is no ' which_atlas ' atlas in participant ' participant{p}]);
        end
        % Find out if the scout you are about to create already exists
        newscout_exists = find(strcmp({Atlas(Pos_main_atlas).Scouts.Label},name_merged_scout), 1);
        if ~isempty(newscout_exists)
            % If it exists, continue to next subject
            continue;
        end
        % Create an empty struct with appropiate fields to store the scouts to merge
        f = fieldnames(Atlas(Pos_main_atlas).Scouts)';
        f{2,1} = {};
        matrix_scouts_to_merge = struct(f{:});   
        % Add the scout information to the newly created struct
        for i = 1:length(scouts_to_merge)
            Pos_scout = find(strcmp({Atlas(Pos_main_atlas).Scouts.Label},scouts_to_merge{i}));
            if isempty(Pos_scout)
                error(['There is no ' scouts_to_merge{i} ' scout in ' which_atlas ' atlas for participant ' participant{p}]);
            end
            matrix_scouts_to_merge(i) = Atlas(Pos_main_atlas).Scouts(Pos_scout);
        end

        % === Join scouts ===
        pos_to_add = length(Atlas(Pos_main_atlas).Scouts)+1;
        Atlas(Pos_main_atlas).Scouts(pos_to_add).Seed = matrix_scouts_to_merge(1).Seed; %#ok<*AGROW>
        Atlas(Pos_main_atlas).Scouts(pos_to_add).Region = matrix_scouts_to_merge(1).Region;
        Atlas(Pos_main_atlas).Scouts(pos_to_add).Handles = [];
        Atlas(Pos_main_atlas).Scouts(pos_to_add).Function = matrix_scouts_to_merge(1).Function;
        try
            Atlas(Pos_main_atlas).Scouts(pos_to_add).Vertices = unique([matrix_scouts_to_merge.Vertices]);
        catch
            % Try again flipping the matrix before
            for i = 1:length(matrix_scouts_to_merge)
                matrix_scouts_to_merge(i).Vertices = matrix_scouts_to_merge(i).Vertices';
            end
            Atlas(Pos_main_atlas).Scouts(pos_to_add).Vertices = unique([matrix_scouts_to_merge.Vertices]);
        end
        Atlas(Pos_main_atlas).Scouts(pos_to_add).Label = name_merged_scout;
        Atlas(Pos_main_atlas).Scouts(pos_to_add).Color = merged_scout_color/255;

        % === Remove old scouts ===
        % RemoveScouts(iScouts);
        if remove_original_scouts == 1
            for i = 1:length(scouts_to_merge)
                Pos_scout = find(strcmp({Atlas(Pos_main_atlas).Scouts.Label},scouts_to_merge{i}));
                Atlas(Pos_main_atlas).Scouts(Pos_scout) = []; 
            end
        end

        % Save back surface file with new Atlas/scouts
        variableInfo = who('-file',[anat_dir Cortex]);
        % Identify variables in file to be sure we save back the same
        save([anat_dir Cortex],variableInfo{:})
    
    end
    
    disp(' ');
    disp('-------------------------');  
    disp(['Scouts merged for ' participant{p} ': reload its anatomy to see new merged scouts']);
    disp(datetime)
    disp(' ');
    
    % Identify subject as completed
    if ~strcmp(participant{p},'@default_subject')
        subject_array{pos_subj,11} = 'Anatomy_ready';
        save([root_dir '/subject_array.mat'],'subject_array')
    end
    
end
end
